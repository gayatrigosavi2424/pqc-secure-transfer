name: Security Scanning and Compliance

on:
  schedule:
    # Run security scans daily at 2 AM UTC
    - cron: '0 2 * * *'
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  # SAST (Static Application Security Testing)
  sast-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: python
        
    - name: Autobuild
      uses: github/codeql-action/autobuild@v2
      
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2
      
    - name: Run Bandit security linter
      run: |
        pip install bandit[toml]
        bandit -r . -f json -o bandit-report.json || true
        
    - name: Upload Bandit results
      uses: actions/upload-artifact@v3
      with:
        name: bandit-results
        path: bandit-report.json

  # Dependency Scanning
  dependency-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Safety check
      run: |
        pip install safety
        safety check --json --output safety-report.json || true
        
    - name: Upload Safety results
      uses: actions/upload-artifact@v3
      with:
        name: safety-results
        path: safety-report.json
        
    - name: Run pip-audit
      run: |
        pip install pip-audit
        pip-audit --format=json --output=pip-audit-report.json || true
        
    - name: Upload pip-audit results
      uses: actions/upload-artifact@v3
      with:
        name: pip-audit-results
        path: pip-audit-report.json

  # PQC Cryptographic Compliance
  pqc-compliance:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: PQC Algorithm Compliance Check
      run: |
        python -c "
        import sys
        
        # Check for approved PQC algorithms
        approved_algorithms = ['Kyber512', 'Kyber768', 'Kyber1024', 'Dilithium2', 'Dilithium3', 'Dilithium5']
        
        print('Checking PQC algorithm compliance...')
        
        # Check configuration files
        import os, yaml, json
        
        config_files = []
        for root, dirs, files in os.walk('.'):
            for file in files:
                if file.endswith(('.yaml', '.yml', '.json')) and 'config' in file.lower():
                    config_files.append(os.path.join(root, file))
        
        compliance_issues = []
        
        for config_file in config_files:
            try:
                with open(config_file, 'r') as f:
                    if config_file.endswith('.json'):
                        config = json.load(f)
                    else:
                        config = yaml.safe_load(f)
                
                # Check for PQC algorithm references
                config_str = str(config).lower()
                for alg in approved_algorithms:
                    if alg.lower() in config_str:
                        print(f'âœ“ Found approved PQC algorithm {alg} in {config_file}')
                        
            except Exception as e:
                print(f'Warning: Could not parse {config_file}: {e}')
        
        # Check source code for deprecated algorithms
        deprecated_patterns = ['rsa', 'ecdsa', 'dsa', 'md5', 'sha1']
        
        for root, dirs, files in os.walk('.'):
            if '.git' in root or '__pycache__' in root:
                continue
            for file in files:
                if file.endswith('.py'):
                    filepath = os.path.join(root, file)
                    try:
                        with open(filepath, 'r') as f:
                            content = f.read().lower()
                            for pattern in deprecated_patterns:
                                if pattern in content and 'import' in content:
                                    compliance_issues.append(f'Potential deprecated crypto in {filepath}: {pattern}')
                    except:
                        pass
        
        if compliance_issues:
            print('Compliance issues found:')
            for issue in compliance_issues:
                print(f'âš ï¸  {issue}')
        else:
            print('âœ“ No PQC compliance issues found')
        
        print('PQC compliance check completed')
        "
        
    - name: Key Size Validation
      run: |
        python -c "
        # Validate that key sizes meet NIST recommendations
        key_size_requirements = {
            'Kyber512': 800,   # bytes
            'Kyber768': 1184,  # bytes  
            'Kyber1024': 1568, # bytes
        }
        
        print('Validating PQC key size requirements...')
        
        try:
            from pqc_secure_transfer import PQCKeyExchange
            
            for algorithm, min_size in key_size_requirements.items():
                try:
                    kex = PQCKeyExchange(algorithm)
                    public_key, secret_key = kex.generate_keypair()
                    
                    if len(public_key) >= min_size:
                        print(f'âœ“ {algorithm} key size valid: {len(public_key)} bytes >= {min_size} bytes')
                    else:
                        print(f'âœ— {algorithm} key size invalid: {len(public_key)} bytes < {min_size} bytes')
                        sys.exit(1)
                        
                except Exception as e:
                    print(f'Warning: Could not test {algorithm}: {e}')
                    
        except ImportError:
            print('PQC modules not available for testing')
            
        print('Key size validation completed')
        "

  # Container Security Scan
  container-security:
    runs-on: ubuntu-latest
    if: github.event_name != 'schedule'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Build test image
      run: |
        docker build -t pqc-security-test:latest .
        
    - name: Run Trivy container scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'pqc-security-test:latest'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os,library'
        severity: 'CRITICAL,HIGH'
        
    - name: Run Docker Bench Security
      run: |
        docker run --rm --net host --pid host --userns host --cap-add audit_control \
          -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
          -v /etc:/etc:ro \
          -v /usr/bin/containerd:/usr/bin/containerd:ro \
          -v /usr/bin/runc:/usr/bin/runc:ro \
          -v /usr/lib/systemd:/usr/lib/systemd:ro \
          -v /var/lib:/var/lib:ro \
          -v /var/run/docker.sock:/var/run/docker.sock:ro \
          --label docker_bench_security \
          docker/docker-bench-security || true

  # Infrastructure Security Scan
  infrastructure-security:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Checkov on Terraform
      uses: bridgecrewio/checkov-action@master
      with:
        directory: terraform/
        framework: terraform
        output_format: sarif
        output_file_path: checkov-terraform.sarif
        
    - name: Upload Checkov results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: checkov-terraform.sarif
        
    - name: Run Checkov on CloudFormation
      uses: bridgecrewio/checkov-action@master
      with:
        directory: cloudformation/
        framework: cloudformation
        output_format: sarif
        output_file_path: checkov-cloudformation.sarif
        
    - name: Upload CloudFormation Checkov results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: checkov-cloudformation.sarif

  # Compliance Report Generation
  compliance-report:
    runs-on: ubuntu-latest
    needs: [sast-scan, dependency-scan, pqc-compliance, container-security, infrastructure-security]
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all artifacts
      uses: actions/download-artifact@v3
      
    - name: Generate compliance report
      run: |
        python -c "
        import json, os, datetime
        
        report = {
            'timestamp': datetime.datetime.utcnow().isoformat(),
            'repository': '${{ github.repository }}',
            'commit': '${{ github.sha }}',
            'branch': '${{ github.ref_name }}',
            'compliance_status': 'PASS',
            'scans': {}
        }
        
        # Check if artifact files exist and process them
        artifact_files = {
            'bandit': 'bandit-results/bandit-report.json',
            'safety': 'safety-results/safety-report.json',
            'pip_audit': 'pip-audit-results/pip-audit-report.json'
        }
        
        for scan_name, file_path in artifact_files.items():
            if os.path.exists(file_path):
                try:
                    with open(file_path, 'r') as f:
                        scan_data = json.load(f)
                    report['scans'][scan_name] = {
                        'status': 'COMPLETED',
                        'issues_found': len(scan_data) if isinstance(scan_data, list) else scan_data.get('results', {}).get('issues', 0)
                    }
                except Exception as e:
                    report['scans'][scan_name] = {
                        'status': 'ERROR',
                        'error': str(e)
                    }
            else:
                report['scans'][scan_name] = {
                    'status': 'NOT_RUN',
                    'reason': 'Artifact not found'
                }
        
        # Save compliance report
        with open('compliance-report.json', 'w') as f:
            json.dump(report, f, indent=2)
            
        print('Compliance report generated:')
        print(json.dumps(report, indent=2))
        "
        
    - name: Upload compliance report
      uses: actions/upload-artifact@v3
      with:
        name: compliance-report
        path: compliance-report.json
        
    - name: Comment PR with compliance status
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          
          try {
            const report = JSON.parse(fs.readFileSync('compliance-report.json', 'utf8'));
            
            let comment = `## ðŸ”’ Security & Compliance Report\n\n`;
            comment += `**Status:** ${report.compliance_status}\n`;
            comment += `**Timestamp:** ${report.timestamp}\n\n`;
            comment += `### Scan Results:\n`;
            
            for (const [scanName, scanData] of Object.entries(report.scans)) {
              const status = scanData.status === 'COMPLETED' ? 'âœ…' : scanData.status === 'ERROR' ? 'âŒ' : 'âš ï¸';
              comment += `- ${status} **${scanName}**: ${scanData.status}`;
              if (scanData.issues_found !== undefined) {
                comment += ` (${scanData.issues_found} issues)`;
              }
              comment += `\n`;
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          } catch (error) {
            console.log('Could not create compliance comment:', error);
          }