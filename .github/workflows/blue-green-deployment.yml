name: Blue-Green Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
        - staging
        - prod
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
      rollback:
        description: 'Rollback to previous version'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: us-west-2

jobs:
  # Blue-Green Deployment Job
  blue-green-deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Set environment variables
      run: |
        echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
        echo "IMAGE_TAG=${{ github.event.inputs.image_tag }}" >> $GITHUB_ENV
        echo "CLUSTER_NAME=pqc-${{ github.event.inputs.environment }}-cluster" >> $GITHUB_ENV
        echo "SERVICE_NAME=pqc-secure-transfer-${{ github.event.inputs.environment }}-service" >> $GITHUB_ENV
        
    - name: Get current deployment info
      id: current
      run: |
        # Get current task definition
        CURRENT_TASK_DEF=$(aws ecs describe-services \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME \
          --query 'services[0].taskDefinition' \
          --output text)
        
        echo "current_task_def=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
        
        # Get current desired count
        CURRENT_COUNT=$(aws ecs describe-services \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME \
          --query 'services[0].desiredCount' \
          --output text)
        
        echo "current_count=$CURRENT_COUNT" >> $GITHUB_OUTPUT
        
    - name: Handle rollback
      if: github.event.inputs.rollback == 'true'
      run: |
        echo "Performing rollback..."
        
        # Get previous task definition
        TASK_DEFINITIONS=$(aws ecs list-task-definitions \
          --family-prefix pqc-$ENVIRONMENT-task \
          --status ACTIVE \
          --sort DESC \
          --query 'taskDefinitionArns[1]' \
          --output text)
        
        if [ "$TASK_DEFINITIONS" != "None" ]; then
          echo "Rolling back to: $TASK_DEFINITIONS"
          
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --task-definition $TASK_DEFINITIONS
            
          echo "Rollback initiated. Waiting for deployment to complete..."
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME
            
          echo "✓ Rollback completed successfully"
        else
          echo "✗ No previous task definition found for rollback"
          exit 1
        fi
        
    - name: Create new task definition
      if: github.event.inputs.rollback != 'true'
      id: new_task_def
      run: |
        # Get current task definition
        CURRENT_TASK_DEF_JSON=$(aws ecs describe-task-definition \
          --task-definition ${{ steps.current.outputs.current_task_def }} \
          --query 'taskDefinition')
        
        # Update image tag in task definition
        NEW_TASK_DEF=$(echo "$CURRENT_TASK_DEF_JSON" | jq --arg IMAGE_TAG "$IMAGE_TAG" '
          .containerDefinitions[0].image = (.containerDefinitions[0].image | split(":")[0] + ":" + $IMAGE_TAG) |
          del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)
        ')
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(echo "$NEW_TASK_DEF" | aws ecs register-task-definition \
          --cli-input-json file:///dev/stdin \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "new_task_def_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT
        echo "New task definition created: $NEW_TASK_DEF_ARN"
        
    - name: Deploy green environment
      if: github.event.inputs.rollback != 'true'
      run: |
        echo "Starting blue-green deployment..."
        
        # Create green service (temporary)
        GREEN_SERVICE_NAME="${SERVICE_NAME}-green"
        
        # Check if green service already exists
        if aws ecs describe-services --cluster $CLUSTER_NAME --services $GREEN_SERVICE_NAME --query 'services[0].serviceName' --output text 2>/dev/null | grep -q "$GREEN_SERVICE_NAME"; then
          echo "Green service exists, updating it..."
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $GREEN_SERVICE_NAME \
            --task-definition ${{ steps.new_task_def.outputs.new_task_def_arn }} \
            --desired-count ${{ steps.current.outputs.current_count }}
        else
          echo "Creating new green service..."
          
          # Get blue service configuration
          BLUE_SERVICE_CONFIG=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --query 'services[0]')
          
          # Create green service with new task definition
          aws ecs create-service \
            --cluster $CLUSTER_NAME \
            --service-name $GREEN_SERVICE_NAME \
            --task-definition ${{ steps.new_task_def.outputs.new_task_def_arn }} \
            --desired-count ${{ steps.current.outputs.current_count }} \
            --launch-type FARGATE \
            --network-configuration "$(echo "$BLUE_SERVICE_CONFIG" | jq '.networkConfiguration')" \
            --load-balancers "$(echo "$BLUE_SERVICE_CONFIG" | jq '.loadBalancers')"
        fi
        
        echo "Waiting for green service to become stable..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --services $GREEN_SERVICE_NAME
          
        echo "✓ Green service is stable"
        
    - name: Health check green environment
      if: github.event.inputs.rollback != 'true'
      run: |
        echo "Performing health checks on green environment..."
        
        # Get green service tasks
        GREEN_TASKS=$(aws ecs list-tasks \
          --cluster $CLUSTER_NAME \
          --service-name "${SERVICE_NAME}-green" \
          --query 'taskArns' \
          --output text)
        
        # Get task details and extract IP addresses
        for TASK_ARN in $GREEN_TASKS; do
          TASK_IP=$(aws ecs describe-tasks \
            --cluster $CLUSTER_NAME \
            --tasks $TASK_ARN \
            --query 'tasks[0].attachments[0].details[?name==`privateIPv4Address`].value' \
            --output text)
          
          echo "Testing health endpoint at $TASK_IP:8765"
          
          # Health check with retry
          for i in {1..10}; do
            if curl -f -s "http://$TASK_IP:8765/health" > /dev/null; then
              echo "✓ Health check passed for task $TASK_ARN"
              break
            fi
            echo "Health check attempt $i/10 failed, retrying..."
            sleep 10
          done
        done
        
        echo "✓ All green environment health checks passed"
        
    - name: Switch traffic to green
      if: github.event.inputs.rollback != 'true'
      run: |
        echo "Switching traffic from blue to green..."
        
        # Update blue service to use green task definition
        aws ecs update-service \
          --cluster $CLUSTER_NAME \
          --service $SERVICE_NAME \
          --task-definition ${{ steps.new_task_def.outputs.new_task_def_arn }}
        
        echo "Waiting for blue service to update..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME
          
        echo "✓ Traffic switched to new version"
        
    - name: Cleanup green environment
      if: github.event.inputs.rollback != 'true'
      run: |
        echo "Cleaning up temporary green service..."
        
        GREEN_SERVICE_NAME="${SERVICE_NAME}-green"
        
        # Scale down green service
        aws ecs update-service \
          --cluster $CLUSTER_NAME \
          --service $GREEN_SERVICE_NAME \
          --desired-count 0
        
        # Wait for tasks to stop
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --services $GREEN_SERVICE_NAME
        
        # Delete green service
        aws ecs delete-service \
          --cluster $CLUSTER_NAME \
          --service $GREEN_SERVICE_NAME
        
        echo "✓ Green service cleanup completed"
        
    - name: Final health check
      run: |
        echo "Performing final health check..."
        
        # Get load balancer DNS name
        LB_DNS=$(aws elbv2 describe-load-balancers \
          --names "pqc-$ENVIRONMENT-alb" \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        SERVICE_URL="http://$LB_DNS"
        echo "Testing service at: $SERVICE_URL"
        
        # Final health check
        for i in {1..20}; do
          if curl -f -s "$SERVICE_URL/health" > /dev/null; then
            echo "✓ Final health check passed"
            
            # Verify PQC functionality
            HEALTH_RESPONSE=$(curl -s "$SERVICE_URL/health")
            if echo "$HEALTH_RESPONSE" | grep -q "healthy"; then
              echo "✓ Service is healthy and operational"
              break
            fi
          fi
          echo "Final health check attempt $i/20..."
          sleep 15
        done
        
        echo "Deployment completed successfully!"

  # Notification
  notify-deployment:
    runs-on: ubuntu-latest
    needs: blue-green-deploy
    if: always()
    
    steps:
    - name: Notify deployment result
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ needs.blue-green-deploy.result }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        custom_payload: |
          {
            "text": "Blue-Green Deployment ${{ needs.blue-green-deploy.result }}",
            "attachments": [{
              "color": "${{ needs.blue-green-deploy.result == 'success' && 'good' || 'danger' }}",
              "fields": [{
                "title": "Environment",
                "value": "${{ github.event.inputs.environment }}",
                "short": true
              }, {
                "title": "Image Tag", 
                "value": "${{ github.event.inputs.image_tag }}",
                "short": true
              }, {
                "title": "Rollback",
                "value": "${{ github.event.inputs.rollback }}",
                "short": true
              }]
            }]
          }